# Testing

Testing is a critical part of software development, and there are various testing strategies and approaches to ensure the quality and reliability of software. Here's a list of some common testing strategies:

1. **Unit Testing**: Testing individual components, functions, or methods in isolation to verify their correctness.

2. **Integration Testing**: Testing the interactions between different components or services to ensure they work together as expected.

3. **Functional Testing**: Evaluating the application's functionality against the specified requirements to ensure it meets user expectations.

4. **End-to-End (E2E) Testing**: Testing the entire application or system from the user's perspective, simulating real user interactions.

5. **Regression Testing**: Re-running tests on previously tested functionality to ensure that new changes haven't introduced defects.

6. **Smoke Testing**: Running a minimal set of tests to check if the most critical features of the application are working, typically done before more extensive testing.

7. **Acceptance Testing**: Confirming that the software meets the acceptance criteria and is ready for deployment.

8. **Load Testing**: Evaluating how the system performs under expected or extreme loads, helping to identify performance bottlenecks.

9. **Stress Testing**: Pushing the system beyond its expected limits to assess how it behaves under extreme conditions.

10. **Usability Testing**: Evaluating the user-friendliness and overall user experience of the software.

11. **Security Testing**: Identifying vulnerabilities and weaknesses in the software's security, including penetration testing and code reviews.

12. **Accessibility Testing**: Ensuring that the software is accessible to users with disabilities, complying with accessibility standards.

13. **Compatibility Testing**: Verifying that the software works correctly on different devices, browsers, or operating systems.

14. **Usability Testing**: Assessing the user-friendliness, intuitiveness, and overall user experience of the software.

15. **Exploratory Testing**: Freestyle testing where testers explore the application to find defects without predefined test cases.

16. **A/B Testing**: Comparing two or more versions of a feature to determine which performs better with users.

17. **Alpha Testing**: Conducting testing within the development environment, often by internal teams, before a beta release.

18. **Beta Testing**: Involving real users to test the software in a live environment before a full release.

19. **Continuous Testing**: Integrating testing into the continuous integration/continuous delivery (CI/CD) pipeline to test code changes automatically.

20. **Static Testing**: Analyzing the code without executing it, often through code reviews and static analysis tools.

21. **Dynamic Testing**: Executing code to uncover runtime defects, such as functional or performance issues.

22. **Mutation Testing**: Introducing small changes (mutations) into the code to determine if tests can detect them, helping assess test quality.

23. **Model-Based Testing**: Generating test cases from a model of the system's behavior.

24. **Fuzz Testing**: Supplying unexpected or random inputs to find vulnerabilities and crashes in the software.

25. **Non-Functional Testing**: Assessing non-functional aspects like performance, security, and scalability.

26. **Boundary Testing**: Focusing on boundary conditions and edge cases to ensure that the software handles them correctly.

27. **Concurrency Testing**: Evaluating how the software behaves under concurrent or multi-threaded scenarios.

28. **Dependency Testing**: Testing how the software interacts with external dependencies, such as APIs or databases.

29. **Compatibility Testing**: Ensuring that the software works on various platforms, browsers, and devices.

30. **Globalization and Localization Testing**: Testing for internationalization (i18n) and localization (l10n) support.

These testing strategies can be used individually or in combination, depending on the project's requirements and goals, to ensure that software is reliable, secure, and meets user expectations.

## TOC

- [Self Testing](./self/README.md)
- [Unit Testing](./unit/README.md)
